

### 第6章　コレクションフレームワーク

1. コレクションフレームワークの基本
* コレクションフレームワークの中でも、最も基本となるのはCollectionインターフェイス。Collectionのサブインターフェイスとして、さらに、List、Set、Queue(Deque)があり、Collectionとは継承関係にないもののMapが加わっコレクションフレームワークの基本的な構成としている。  
* コレクションの基本構文  
→インターフェイス型  
→ジェネリクス構文  
* コーディング上のイディオム  
→コレクション初期化  
→コレクションを順に処理する 拡張for命令を使用  
* 配列⇔コレクションの変換  
→配列→リスト Arrays.asListメソッドを使用  
→配列→リスト(コピー) Collections.addAll静的メソッドを使用  
→コレクション→配列 toArrayメソッドを使用  
* 特殊なコレクションの作成  
→変更不能コレクションへの変換 unmodifiableXxxxxメソッドを使用  
→変更不能コレクションの生成 ofメソッドを使用  
→空コレクションの生成  emptyXxxxxメソッドを使用  
2. リスト  
* ArrayList(サイズ可変の配列)  
→内部的には配列を利用したデータ構造です。ただし、配列とは異なり、あとからでもサイズを変更できる。  
* LinkedList(二重リンクリスト)  
→ArrayListで利用できるメンバーに加えP243 表6.6のメンバーが用意されている。  
3. セット  
リストと違いセットは要素の重複を許さない。数学における集合の概念に似ており、ある要素(群)がセットに含まれているか、他のセットとも包含関係に関心があるような状況で使用する。  
* セットの基本操作(HashSet)  
→P251 表6.7参照  
* TreeSet(ソート済セット)  
→並び順を管理する。追加された要素が自動的にソートされる点を除けば、HashSetと同じ挙動となる。P253 表6.8参照  
4. マップ  
一意のキーと値のペアで管理されているデータ構造。言語によってはディクショナリ(辞書)、ハッシュ、連想配列と呼ぶ場合もある。個々の要素に対して(インデックスではなく)キーと言う意味ある情報でアルセスができる。  
* HashuMap(ハッシュ表)  
最も基本的なマップの実装。キーの順序は保証されない。  
内部的にはハッシュ表(ハッシュテーブル)と呼ばれる配列を持つ。要素を保存する際に、キーからハッシュ値を求めることで、ハッシュ表のどこに値(オブジェクト)を保存するのに決定する。 
→hashCodeメソッドは適切に実装する。  
→ハッシュ表のサイズを適切に設定する。  
→HashMapで用意されているメンバー P257 表6.9参照  
* TreeMap(ソート済マップ)  
キーの順序を管理できるマップです。キーをRed-Blackツリーで管理し、キーの大小で並びを管理できるのが特徴。  
→キーの順序をカスタマイズ 既定でキーとなる型の自然順序(文字列ならば辞書順、数値ならば大小順)に従って、要素の並びを決定する。標準の並びを順を変更したい場合は、インスタンス化するときにラムダ式を渡すようにする。  
→NavigableMapによるあいまい検索  指定されたキーそのものではなく、そのキーに最も近いキーを取得するためのメソッドを提供する。  
5. スタック/キュー  
リストの両端からの値の出し入れに特化したデータ構造のこと。  
スタック(stack)とは後入れ先出し(LIFO:Last In First Out)、または先入れ後出し(FILO:First In Last Out)とも呼ばれる構造。  
キュー(Queue)は先入れ先出し(FIFO:First In First Out)と呼ばれるデータ構造。  
* ArrayDeque(両端キュー)  
→循環配列のこと。循環配列とは、基本的には配列だが、先頭から順に要素を格納するのではなく、配列内の任意の範囲に要素を格納しているのが特徴。P268 表6.11参照  






